{
  "language": "Solidity",
  "sources": {
    "contracts/secureDocument.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.8.7;\n\ncontract secureDocument {\n    /*STATE VARIABLES */\n\n    address private i_owner;\n    event ReturnContrctId(address from_sender, address contractId);\n    event returnLoginStatus(bool status, address opadd);\n\n    /*WHAT THE CONTRACT IS MEANT TO PERFORM*/\n\n    //creating the struct to add all the OPERATORS in the system\n    //Be able to map the documents and operators address\n    // struct for all documents added in the system\n    // provide prreveledge with respect to _type\n    // verify documents against the hash value\n    // mapp the document with respect to the sender\n    //map document with respect to the receiver\n    //return all the user\n    //adding the operators\n    //validate the operators\n\n    /*listing and adding the organisation*/\n    struct Organisations {\n        string orgName;\n        address orgAddress;\n        string[] members;\n        string officeLocation;\n    }\n    Organisations[] organisationArray;\n\n    /*mapping the address to organisation */\n    mapping(address => Organisations) public organisationAvaailable;\n\n    //   Organisations  org2 = organisationAvaailable[address];\n\n    // function testingAddress(address orgadd) public view returns(Organisations memory) {\n\n    //            Organisations memory foundOrg = organisationAvaailable[orgadd];\n\n    // //             for(uint i; i<organisationArray.length; i++){\n    // //                 if (organisationArray[i].orgAddress == orgadd){\n    // //                     foundOrg = organisationArray[i];\n\n    // //                 }\n\n    // // }\n    // return foundOrg;\n    // //0x70997970C51812dc3A010C7d01b50e0d17dc79C8\n\n    // }\n\n    function isAvailable(address orgadd) public view returns (bool) {\n        bool result = false;\n        for (uint i; i < organisationArray.length; i++) {\n            if (organisationArray[i].orgAddress == orgadd) {\n                result = true;\n                break;\n            } \n        }\n        return result;\n    }\n\n    /* struct for operators*/\n\n    struct Operators {\n        string name;\n        string organisation;\n        address _userAdd;\n        string position;\n        string[] documents;\n    }\n\n    /*create array of type operators*/\n\n    Operators[] private operatorsArray;\n\n    /* struct of documents/ currently */\n    struct Document {\n        string cidValue;\n        address sender;\n        string description;\n        string docName;\n        string time;\n    }\n     struct Users{\n        address userAddres;\n        string  userType;\n    }\n Users[] userArray;\n\n    struct Shares {\n        address sender;\n        address receiver;\n        string time;\n    }\n\n    struct docShares {\n        string cidValue;\n        Shares[] share;\n    }\n\n    /* creating array of documents */\n    Document[] public documentArray;\n\n    /* map the contracts and address */\n    mapping(address => Operators) operators;\n    mapping(string => docShares) DocumentShares;\n    mapping(string => Document) documentMapping;\n      mapping(address=>Users) public usersMapping;\n\n    /* constructor to initialize the value to stay forever*/\n  constructor() {\n        i_owner = msg.sender;\n\n        usersMapping[i_owner].userType =\"admin\";\n       \n    }\n\n    /*method adding the institution*/\n    function addOrganisation(\n      \n        string memory name,\n        address orgAdd,\n        string memory location\n    ) public ownerOnly {\n        Organisations memory newOrg = Organisations({\n            orgName: name,\n            orgAddress: orgAdd,\n            members: new string[](0),\n            officeLocation: location\n        });\n        organisationArray.push(newOrg);\n\n         Users memory newUser = Users({\n            userAddres:orgAdd,\n            userType:\"institution\"\n\n\n        });\n       \n      \n          userArray.push(newUser);\n        usersMapping[orgAdd].userType =\"institution\";\n    }\n\n    /*retrievuing the organisation from the blockchain*/\n\n    /*mapping the address to organisation */\n\n    function testingAddress(address orgadd)\n        public\n        view\n        returns (Organisations memory)\n    {\n        Organisations memory foundOrg;\n\n        for (uint i; i < organisationArray.length; i++) {\n            if (organisationArray[i].orgAddress == orgadd) {\n                foundOrg = organisationArray[i];\n            }\n        }\n        return foundOrg;\n    }\n\n    function getOrganisation() public view returns (Organisations[] memory) {\n        return organisationArray;\n    }\n\n  /* method to add operators */\n    function addOperators(\n        string memory name,\n        string memory org,\n        address _userId,\n        string memory position\n        \n     \n    ) public  {\n        // Organisations storage thisOrg = organisationAvaailable[msg.sender];\n        // string[] storage storeMembers = thisOrg.members;\n        \n \n            Operators memory newOperator = Operators({\n            name:name,\n            organisation: org,\n            _userAdd: _userId,\n            position: position,\n            documents: new string[](0)\n        });\n        operatorsArray.push(newOperator);\n        Users memory newUser = Users({\n            userAddres:_userId,\n            userType:\"operator\"\n\n\n        });\n       userArray.push(newUser);\n        usersMapping[_userId].userType =\"operator\";\n        // storeMembers.push(position);\n         \n    }\n\n    /*view operators*/\n    /*opr is supposed to be in the array*/\n    function getOperators(string memory org)\n        public\n        view\n        returns (Operators memory)\n    {\n        Operators memory opr;\n        for (uint256 i; i < operatorsArray.length; i++) {\n            if (\n                keccak256(bytes(operatorsArray[i].organisation)) ==\n                keccak256(bytes(org))\n            ) {\n                opr = operatorsArray[i];\n            }\n        }\n        return opr;\n    }\n\n    /* verify operators on login */\n\n    \n    function operatorLogin(address add) public view returns (string memory) {\n       \n   \n     return usersMapping [add].userType;\n       \n    }\n\n        /* verify operators on login  */\n\n    function operatorFinder(address add) public view returns (Operators memory) {\n        Operators memory val;\n\n        for (uint256 i = 0; i < operatorsArray.length; i += 1) {\n            if (add == operatorsArray[i]._userAdd) {\n                val = operatorsArray[i];\n            }\n        }\n        return val;\n    }\n\n    /* send the document by specify the the receiver address */\n    // passing the address of the receiver\n\n    function sendDocument(\n        address _receiver,\n        string memory _cidValue,\n        string memory _time,\n        string memory comment,\n        string memory _docName\n    ) public returns (bool) {\n        operators[_receiver].documents.push(_cidValue);\n        DocumentShares[_cidValue].cidValue = _cidValue;\n        DocumentShares[_cidValue].share.push(\n            Shares(msg.sender, _receiver, _time)\n        );\n\n        /* adding the document to the it's array if it's not available yet */\n        // bool isAvail = presenceChecker(hashedDocument);\n        // if (!isAvail) {\n\n        Document memory newdocument = Document({\n            cidValue: _cidValue,\n            sender: msg.sender,\n            time: _time,\n            description: comment,\n            docName: _docName\n        });\n\n        documentArray.push(newdocument);\n        return true;\n    }\n\n    // receive the document\n    function receivedDocs() public view returns (Document[] memory) {\n        uint256 arrayLength = documentArray.length;\n        Document[] memory foundDocArray = new Document[](arrayLength);\n\n        string[] memory doc = operators[msg.sender].documents;\n        for (uint i; i < doc.length; i++) {\n            for (uint j; j < documentArray.length; j++) {\n                if (\n                    keccak256(bytes(documentArray[j].cidValue)) ==\n                    keccak256(bytes(doc[i]))\n                ) {\n                    foundDocArray[j] = documentArray[j];\n                }\n            }\n        }\n\n        return foundDocArray;\n    }\n\n    /*storing documents*/\n    function store(\n        string memory _cidValue,\n        string memory _time,\n        string memory comment,\n        string memory _docName\n    ) public {\n        /* adding the document to the it's array if it's not available yet */\n        Document memory newdocument = Document({\n            cidValue: _cidValue,\n            sender: msg.sender,\n            docName: _docName,\n            time: _time,\n            description: comment\n        });\n        documentArray.push(newdocument);\n    }\n\n    /* verifying document */\n    mapping(string => Document) public foundDoc;\n\n    function verifyDocument(string memory _cid) public view returns (bool) {\n        bool val;\n        for (uint i; i < documentArray.length; i++) {\n            if (\n                keccak256(bytes(documentArray[i].cidValue)) ==\n                keccak256(bytes(_cid))\n            ) {\n                val = true;\n            } else {\n                val = false;\n            }\n        }\n        return val;\n    }\n\n    /*MODIFIERS */\n    modifier ownerOnly() {\n        require(msg.sender == i_owner, \"you aren't owner\");\n        _;\n    }\n\n    modifier Registered() {\n\n        for (uint256 i = 0; i < operatorsArray.length; i += 1) {\n            if (msg.sender == operatorsArray[i]._userAdd) {\n               _;\n            }  \n        }\n       \n    }\n\n    /* INDIRECT METHODS \n\n/* Testing function to retrieving operators */\n    function getOperators(uint256 index)\n        public\n        view\n        returns (Operators memory)\n    {\n        return operatorsArray[index];\n    }\n\n    /*testing function to view the documents in the addresses */\n    function getDocuments(address oppadd)\n        public\n        view\n        returns (Document[] memory)\n    {\n        uint256 arrayLength = documentArray.length;\n        Document[] memory foundDocument = new Document[](arrayLength);\n        uint256 j;\n        for (uint256 i; i < documentArray.length; i++) {\n            if (documentArray[i].sender == oppadd) {\n                foundDocument[j] = documentArray[i];\n                j++;\n            }\n        }\n        return foundDocument;\n    }\n\n    /*checking the documents in the document array*/\n    function presenceChecker(string memory hashedDoc)\n        public\n        view\n        returns (bool)\n    {\n        bool val;\n        for (uint256 i; i < documentArray.length; i += 1) {\n            //keccak256(bytes(a)) == keccak256(bytes(b)); = using this when comparing string literals\n\n            if (\n                keccak256(bytes(hashedDoc)) ==\n                keccak256(bytes(documentArray[i].cidValue))\n            ) {\n                val = true;\n            } else {\n                val = false;\n            }\n        }\n\n        return val;\n    }\n\n/*checking the documents shares */\nfunction getShares(string memory _cidValue) public view returns(Shares[] memory) {\n     Shares[] memory docShare = DocumentShares[_cidValue].share;\n      return docShare;\n\n  \n}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}